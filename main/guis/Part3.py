# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'interface.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import os 
import sys
import torch
import pydicom
import numpy as np 

o_path = os.getcwd()
sys.path.append(o_path)
import cv2
import numpy as np 
        
    

def generete_mask(img, mask_lft, mask_rght, cg_lft, cg_rght, rszd_w=256):
    h, w = img.shape 
    background = np.zeros((h, w, 3)) 
    background = cv2.resize(background, (rszd_w*2, int(h * rszd_w * 2 / w)))
    
    tp_pd, bttm_pd, lft_pd, rght_pd = cg_lft['top_padding'], cg_lft['bottom_padding'], cg_lft['left_padding'], cg_lft['right_padding']
    mask_lft = mask_convert(tp_pd, bttm_pd, mask_lft)

    # mask_lft = mask_lft[tp_pd:-bttm_pd, :, :2]
    background[:, :rszd_w, :2] = mask_lft
    
    tp_pd, bttm_pd, lft_pd, rght_pd = cg_rght['top_padding'], cg_rght['bottom_padding'], cg_rght['left_padding'], cg_rght['right_padding']

    # mask_rght = mask_rght[tp_pd:-bttm_pd, :, :2]
    mask_rght = mask_convert(tp_pd, bttm_pd, mask_rght)
    mask_rght = mask_rght[:, ::-1, :]
    background[:, rszd_w:, :2] = mask_rght
    
    # alpha = np.logical_or(background[..., 0] > 0, background[..., 1] > 0)
    # alpha = alpha.astype('float64') * 0.1
    # background[..., 3] = alpha 
    return background


def mask_convert(tp_pd, bttm_pd, mask):
    if tp_pd > 0:
        mask = mask[tp_pd:]
    else:
        mask = cv2.copyMakeBorder(mask, -tp_pd, 0, 0, 0, cv2.BORDER_CONSTANT, None, (0, 0, 255))
    if bttm_pd > 0:
        mask = mask[:-bttm_pd]
    else:
        mask = cv2.copyMakeBorder(mask, 0, -bttm_pd, 0, 0, cv2.BORDER_CONSTANT, None, (0, 0, 255))
    return mask[..., :2]


def filter_annotation(mask):
    
    femur = filter_mask(mask[..., 1])
    tibia = filter_mask(mask[..., 0])
    mask_of_mask = np.stack([tibia, femur, np.ones(femur.shape)], axis=2).astype('uint8')
    mask = mask * mask_of_mask
    blank = np.logical_and(mask[..., 0] == 0, mask[..., 1] == 0)
    blank = np.logical_and(blank, mask[..., 2] == 0)
    mask[blank] = np.array([0, 0, 255], dtype='uint8')
    
    return mask


def filter_mask(mask):
    """Filter binary masks through connected component analysis

    Args:
        mask (np.array([h, w])): binrary masks

    Returns:
        np.array([h, w]): filtered binrary masks which keeps the largest foreground area, these are usually the bone mask we want
    """
    _, labels, stats, _ = cv2.connectedComponentsWithStats(mask, 8, cv2.CV_16S)
    area = stats[:, cv2.CC_STAT_AREA].squeeze()
    if area.size < 2:
        return np.ones(mask.shape)
    label = np.argsort(area)[-2]
    return (labels == label).astype('float32')




def shrinking_mask(mask, ksize=7, sigma=6, shrinking_level=2):
    res = []
    for i in range(2):
        mask_i = mask[..., i]
        mask_i = cv2.GaussianBlur(mask_i, 2*(ksize,), sigma)
        mask_i = np.where(mask_i > 127, 255, 0).astype('uint8')
        usdf_i = cv2.distanceTransform(mask_i, cv2.DIST_L2, cv2.DIST_MASK_PRECISE)
        mask_i = mask_i * (usdf_i >= shrinking_level).astype('uint8') 
        res.append(mask_i)
    background = np.zeros(mask.shape[:-1], dtype='uint8')
    res.append(background)
    return np.stack(res, axis=-1)
